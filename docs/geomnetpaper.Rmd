---
output: html_document
---
# Drawing Networks with the R package `ggplot2` {#ch3}

This next section is a paper I authored with Heike Hofmann (Iowa State University) and François Briatte (European School of Political and Social Sciences) that will be published in the R Journal.  

## Introduction 

```{r setupknitr, echo=FALSE}
library(knitr)
opts_chunk$set(
  tidy = FALSE, echo = TRUE, cache = TRUE, eval = TRUE,
  message = FALSE, warning = FALSE, highlight = FALSE, 
  background = '#FFFFFF', dev = 'png', 
  fig.height = 8, fig.width = 8, fig.align = 'center'
)

# ## From Josh O'Brien's stackoverflow answer:
# ## http://stackoverflow.com/questions/11030898/knitr-how-to-align-code-and-plot-side-by-side
# ## These two settings control text width in codefig vs. usual code blocks
# partWidth <- 35
# fullWidth <- 60
# options(width = fullWidth)
# 
# ##  (1) CHUNK HOOK FUNCTION
# ##   First, to set R's textual output width on a per-chunk basis, we
# ## need to define a hook function which temporarily resets global R's
# ## option() settings, just for the current chunk
# knit_hooks$set(r.opts = local({
#     ropts <- NA
#     function(before, options, envir) {
#         if (before) {
#             ropts <<- options(options$r.opts)
#         } else {
#             options(ropts)
#         }
#     }
# }))
# 
# ## (2) OUTPUT HOOK FUNCTION
# 
# ##   Define a custom output hook function. This function processes _all_
# ## evaluated chunks, but will return the same output as the usual one,
# ## UNLESS a 'codefig' argument appeared in the chunk's header.  In that
# ## case, wrap the usual textual output in LaTeX code placing it in a
# ## narrower adjustbox environment and setting the graphics that it
# ## produced in another box beside it.
# 
# defaultChunkHook <- environment(knit_hooks[["get"]])$defaults$chunk
# 
# codefigChunkHook <- function(x, options) {
#         main <-  defaultChunkHook(x, options)
#         before <-
#             "\\vspace{1em}\n
#              \\begin{adjustbox}{valign=t}\n
#              \\begin{minipage}{.49\\textwidth}\n"
#         after <-
#             paste("\\vspace{1em}\n
#                    \\end{minipage}\n
#                   \\begin{minipage}{.49\\textwidth}\n",
#                    paste0("\\includegraphics[width=\\textwidth]{figure/",
#                           options[["label"]], "-1.pdf}\n
#                           \\end{minipage}\n
#                           \\end{adjustbox}"),
#                           sep = "\n")
#     ## Was a codefig option supplied in chunk header?
#     ## If so, wrap code block and graphical output with needed LaTeX code.
#     if (!is.null(options$codefig)) {
#       return(sprintf("%s %s %s", before, main, after))
#     } else {
#       return(main)
#     }
# }
# 
# knit_hooks[["set"]](chunk = codefigChunkHook)
# 
# 
# ## (3) TEMPLATE
# ##   codefig=TRUE is just one of several options needed for the
# ## side-by-side code block and a figure to come out right. Rather
# ## than typing out each of them in every single chunk header, we
# ## define a _template_ which bundles them all together. Then we can
# ## set all of those options simply by typing opts.label="codefig".
# 
# opts_template[["set"]](
# codefig = list(codefig = TRUE, fig.show = "hide",
#                r.opts = list(width = partWidth),
#                tidy.opts = list(width.cutoff = partWidth)))
```


```{r load_packages, echo=FALSE, results='hide'}
library(dplyr)
library(tidyr)
library(ggplot2) # needs to be version ≥ 1.0.1.9003
library(scales)

## ggnet2
# if (!require(ggnet, quietly = TRUE)) {
#   devtools::install_github("briatte/ggnet")
# }
# library(ggnet)
if (!require(GGally, quietly = TRUE)) {
  devtools::install_github("ggobi/ggally")
}

## geom_net
if (!require(geomnet, quietly = TRUE)) {
  devtools::install_github("sctyner/geomnet")
}

## ggnetwork
if (!require(ggnetwork, quietly = TRUE) ||
    packageVersion("ggnetwork") < "0.2.1") {
  devtools::install_github("briatte/ggnetwork")
}

## pre-load
library(network)
library(sna)
```

There are many kinds of networks, and networks are extensively studied across many disciplines [@watts2004ars]. For instance, social network analysis is a longstanding and prominent sub-field of sociology, and the study of biological networks, such as protein-protein interaction networks or metabolic networks, is a notable sub-field of biology [@prell2011social, @junker2008analysis]. In addition, the ubiquity of social media platforms, like Facebook, Twitter, and LinkedIn, has brought the concepts of networks out of academia and into
the mainstream. Though these disciplines and the many others that study networks are themselves very different and specialized, they can all benefit from good network visualization tools.

Many R packages already exist to manipulate network objects, such as `statnet` by @statnet, `igraph` by @igraph, `sna` by @sna, and `network` by @network [see also @network.jss]. Each one of these packages were developed with a focus of analyzing network data and not necessarily for rendering visualizations of networks. Though these packages do have network visualization capabilities, visualization was not intended as their primary purpose. This is by no means a critique or an inherently negative aspect of these packages: they are all hugely important tools for network analysis that we have relied heavily on in our own work.  We have found, however, that visualizing network data in these packages requires a lot of extra work if one is accustomed to working with more ``traditional" data structures such as vectors, data frames, or arrays. The visualization tools in these packages require detailed knowledge of each one of them and their syntax in order to build meaningful network visualizations with them. This is obviously not a problem if the user is very familiar with network structures and has already spent time working with network data. If, however, the user is new to network data or is more comfortable working with the traditional data structures, they could find the learning curve for these packages burdensome.

The packages we have written have one primary purpose: to create beautiful network visualizations by providing a wrapper to the popular `ggplot` package @ggplot2. And so, our focus here is not on adding to the analysis of network data or to the field of graph drawing, @graphdrawing but rather it is on implementing existing graph drawing capabilities in the `ggplot` framework, using the more traditional data frame structure. 

The `ggplot` package was designed as an implementation of the "grammar of graphics" proposed by @wilkinson:1999, and it has become extremely popular among R users.^[In order to give an indication of how  large the user base of  `ggplot2` is, we looked at its usage statistics from January 1, 2015 to December 31, 2015 (see [link](http://cran-logs.rstudio.com/)). Over this period, the `ggplot2` package was downloaded over 1.75 million times from CRAN, which amounts to over 6,200 downloads per day. Over 700 R packages list `ggplot2` as a dependency or as a suggestion.]

Because the syntax implemented in the `ggplot2` package is extendable to  different kinds of visualizations, many packages have built additional functionality on top of the  `ggplot2` framework. Examples include the `ggmap` package by @ggmap for spatial visualization, the `ggfortify` package by @ggfortify for visualizing statistical models, the package `ggally` by @GGally, which encompasses various complementary visualization techniques to `ggplot2`, and the `ggbio` and `ggtree` Bioconductor packages by @ggbio and @ggtree, which both provide visualizations for biological data.

These packages have expanded the utility of `ggplot2`, likely resulting in an  increase of its user base. We hope to appeal to this user base and potentially add to it by applying the benefits of the grammar of graphics implemented in `ggplot2` to network visualization. Our efforts rely upon the most recent changes to `ggplot2`, which allow users to more easily extend the package through additional geometries or `geoms`.^[Version 2.1.0, released 1 March 2016. See [](https://cran.r-project.org/web/packages/ggplot2/news.html) for the full list of changes in `ggplot2` 2.1.0, as well as the new package vignette, "Extending ggplot2"", which explains how the internal `ggproto` system of object-oriented programming can be used to create new geoms.]  

In the remainder of this paper, we present three different approaches to network visualization through `ggplot2` wrappers. The section \@ref(background) introduces the basic terminology of networks and illustrates their ubiquity in natural and social life. The next section \@ref(implementations) then discusses the logic behind each of the three approaches that we offer. The section \@ref(examples) extends that discussion through several examples ranging from simple to complex networks, for which we provide the code corresponding to each approach alongside its graphical result. We follow with some considerations of runtime behavior in plotting networks in the section \@ref(sec:speed) before closing with a discussion.

## Brief introduction to networks

In its essence, a network is simply a set of vertices connected in pairs by a set of edges [@newman]. Throughout this paper, we also use the terms "nodes" and "actors" to refer to vertices, as well as the terms "ties" and "relationships" to refer to edges. The two sets of graphical objects that make up a network visualization or mapping, points and the segments between them, have been used to examine a huge variety and quantity of information across many different fields of study. For instance, networks of scientific collaboration, a food web of marine animals, and American college football games are all covered in a paper on community detection in networks by @football. Additionally, @networkfailures study node failure in interdependent networks like power grids.  Social networks such as links between actors found on [](http://www.imdb.com/) and neural networks, like the completely mapped neural network of the *C. elegans* worm are also extensively studied [@smallworld].

These examples show that networks can vary widely in scope and complexity: the smallest network with connections is just one edge between two vertices, while one of the most commonly used and most complex networks, the world wide web, has billions of vertices (Web pages) and billions of edges (hyperlinks) connecting them. Additionally, the edges in a network can be directed or undirected: directed edges represent an ordering of vertices, like a relationship extending from one vertex to another, where switching the direction would change the structure of the network. The World Wide Web is an example of a directed network because hyperlinks connect one Web page to another, but not necessarily the other way around. Undirected edges are simply connections between vertices where order does not matter. Co-authorship networks are examples of undirected networks, where nodes are authors and they are connected by an edge if they have written an academic publication together.

As a reference example, we turn to a specific instance of a social network. A social network is a network that everyone is a part of in one way or another, whether through friends, family, or other human interactions. We do not necessarily refer here to social media like Facebook or LinkedIn, but rather to the connections we form with other people. To demonstrate the functionality of our tools for plotting networks, we have chosen an example of a social network from the popular television show \emph{Mad Men}. This network, which was compiled by @madmen and made available in `gcookbook` [@gcookbook], is made up of 52 vertices and 87 edges. Each vertex represents a character on the show, and there is an edge between every two characters who have had a romantic relationship.

```{r madmen-geom-net, fig.width=7, fig.height=7.5, fig.cap="Graph of the characters in the show Mad Men who are linked by a romantic relationship.", out.width=".4\\linewidth", echo=FALSE, eval= TRUE}
# make data accessible 
data(madmen, package = "geomnet")

# code for geom_net
# data step: merge edges and nodes
MMnet <- merge(madmen$edges, madmen$vertices,
               by.x = "Name1", by.y = "label", all = TRUE)
# create plot
set.seed(10052016)
ggplot(data = MMnet, aes(from_id = Name1, to_id = Name2)) +
  geom_net(aes(colour = Gender), size = 1, label = TRUE,
           vjust = -0.6, ecolour = "grey60", directed = TRUE, 
           arrowgap = 0.02, arrowsize = 0, ealpha = 0.5) +
  scale_colour_manual(values = c("#FF69B4", "#0099ff")) +
  xlim(c(-0.05, 1.05)) +
  theme_net() +
  theme(legend.position = "bottom")
```

Figure \@ref(madmen-geom-net) is a visualization of this network. In the plot, we can see one central character who has many more relationships than any other character. This vertex represents the main character of the show, Don Draper, who is quite the "ladies' man." Networks like this one, no matter how simple or complex, are everywhere, and we hope to provide the curious reader with a straightforward way to visualize any network they choose.

Coloring the vertices or edges in a graph is a quick way to visualize grouping and can help with pattern or cluster detection. The vertices in a network and the edges between them compose the structure of a network, and being able to visually discover patterns among them is a key part of network analysis. Viewing multiple layouts of the same network can also help reveal patterns or clusters that would not be discovered when only viewing one layout or analyzing only its underlying adjacency matrix.

## Three implementations of network visualizations {#implementations}

We present two basic approaches to using the `ggplot2` framework for network visualization. First, we implement network visualizations by providing a wrapper function, `ggnet2` for the user to visualize a network using `ggplot2` elements. Second, we implement network visualizations using layering in `ggplot2`.  For the second approach, we have two ways of creating a network visualization. The first, `geomnet`, wraps all network structures, including vertices, edges, and vertex labels into a single `geom`. The second, `ggnetwork`, implements each structural component in an independent `geom` and layers them to create the visualization. In each package, our goal is to provide users with a way to map network properties to aesthetic properties of graphs that is familiar to them and straightforward to implement. Each package has a slightly different approach to accomplish this goal, and we will discuss all of these approaches in this section.

### The `ggnet2` function

The `ggnet2` function is an improved version of the `ggnet` function. Both functions  are part of the `GGally` package [@GGally].  A detailed description of the `ggnet2` function is available from within the package as a vignette.^[The vignette can be viewed online at [](https://briatte.github.io/ggnet/)] 
The `ggnet2` function offers a large range of network visualization functionality in a single function call. Although its result is a `ggplot2` object that can be further styled with `ggplot2` scales and themes, the syntax of the `ggnet2` function is designed to be easily understood by the user. The aesthetics relating to the nodes are controlled by arguments such as `node.alpha` or `node.color`, while those relating to the edges are controlled by similarly named arguments starting with `edge`. As a consequence, while `ggnet2` applies the grammar of graphics to network objects, the function itself still works very much like the plotting functions of the `igraph` and `network` packages: a long series of arguments is used to control every possible aspect of how the network should be visualized.

The `ggnet2` function takes a single network object as input. This initial object might be an object of class `network` (with the exception of hypergraphs or multiplex graphs), or any data structure that can be coerced to an object of that class, such as an incidence matrix, an adjacency matrix, or an edge list. Additionally, if the `intergraph` package [@intergraph] is installed, the function  also accepts a network object of class `"igraph"`. Internally, the function converts the network object to two data frames: one for edges and another one for nodes. It then passes them to `ggplot2`. Each of the two data frames contain the information required by `ggplot2` to plot segments and points respectively, such as a shape for the points (nodes) and a line type for the segments (edges). The final result returned to the user is a plot with a minimum of two layers, or more if there are edge and/or node labels.%

The `mode` argument of `ggnet2` controls how the nodes of the network are to be positioned in the plot returned by the function. This argument can take any of the layout values supported by the `gplot.layout` function of the `sna` package, and defaults to `fruchtermanreingold`, which places the nodes through the force-directed layout algorithm by @fruchterman_reingold. Many other possible layouts and their parameters can also be passed to `ggnet2` through the `layout.par` argument. For a list of possible layouts and their arguments, see `?sna::gplot.layout`.

Other arguments passed to the `ggnet2` function offer extensive control over the aesthetics of the plot that it returns, including %through
the addition of edge and/or node labels and their respective aesthetics.
Arguments such as `node.shape` or `edge.lty`, which  control the shape of the nodes and the line type of the edges, respectively, can take a global value, such as `15` or `dashed`, a vector of global values, or the name of an edge or vertex attribute, in which case the values of that attribute are used as the mapping aesthetic.

This last functionality builds on one of the strengths of the `network` class, which can store information on network edges and nodes as attributes that are then accessible to the user through the `\%e\%` and `\%v\%` operators respectively.^[See @network, p. 22-24. The equivalent operators in the `igraph` package are called `E` and `V`.] 

If the `ggnet2` function is given the `node.alpha = "importance"` argument, it will interpret it as an attempt to map the vertex attribute called `importance` to the transparency level of the nodes. This works exactly like the command `net \%v\% "importance"`, which returns the vertex attribute `importance` of the `"network"` object `net`. This functionality allows the `ggnet2` function to work in a similar fashion to `ggplot2` mappings of aesthetics within the `aes` operator.

The `ggnet2` function also provides a few network-specific options, such as sizing the nodes as a function of their unweighted degree, or using the primary and secondary modes of a bipartite network as an aesthetic mapping for the nodes.

All in all, the `ggnet2` function combines two different kinds of processes: it translates a network object into a data frame suitable for plotting with `ggplot2`, and it applies network-related aesthetic operations to that data frame, such as coloring the edges in function of the color of the nodes that they connect. 

### The `geomnet` Package

